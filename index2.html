<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Emotion Mapper</title>
  <style>
    .hidden { display: none; }
    fieldset { margin-bottom: 1.25rem; }
    h1,h2,h3,h4 { margin: .3rem 0; }
    .summary { border-top: 2px solid #ccc; padding-top: 1rem; margin-top: 1rem; }
    button { margin-top: .5rem; margin-right: .5rem; }
    .sr-only {
      position: absolute;
      left: -9999px;
      width: 1px;
      height: 1px;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <main role="main">
    <h1>Emotion Identification Tool</h1>

    <form id="emotionForm" onsubmit="return false;">
      <!-- Step 1 -->
      <fieldset id="step1">
        <legend>Sensations</legend>
        <div id="sensationsContainer" role="region" area-label="Current sensations"></div>
        <button type="button" id="step1Btn">Next</button>
      </fieldset>

      <!-- Step 2 -->
      <fieldset id="step2" class="hidden" aria-live="polite" aria-atomic="true">
        <legend>Core Emotions</legend>
        <div id="emotionContainer" role="region" aria-label="Current core emotion"></div>
        <button type="button" id="prevEmotionBtn" aria-controls="emotionContainer">Back</button>
        <button type="button" id="nextEmotionBtn" aria-controls="emotionContainer">Next Emotion</button>
      </fieldset>

      <!-- Summary -->
      <div id="summary" class="summary hidden" role="region" aria-label="Summary" aria-live="polite"></div>
    </form>
  </main>

  <script>
    let dataset = {};
    let newDataset = {};
    // {bodyPart: {sensation: emotion, sensation: emotion}}
    let allSensations = {};

    async function loadDataset() {
      const response = await fetch('dataset.json');
      dataset = await response.json();

      const newResponse = await fetch('datasetNew.json');
      newDataset = await newResponse.json();

      //invert data object to sensation : emotion
      let sensations, sensation;
      for (const emotion in newDataset){
        sensations = newDataset[emotion].sensations;
        for (const bodyPart in sensations){
          if (allSensations[bodyPart] === undefined) {
            allSensations[bodyPart] = {};
          }
          sensations[bodyPart].forEach(sensation => {
            allSensations[bodyPart][sensation] = emotion;
          });
        }
      }
      generateSensations();
    }

    const sensationsContainer = document.getElementById('sensationsContainer');
    const step1 = document.getElementById('step1');
    const step1Btn = document.getElementById('step1Btn');
    const step2 = document.getElementById('step2');
    const emotionContainer = document.getElementById('emotionContainer');
    const nextEmotionBtn = document.getElementById('nextEmotionBtn');
    const prevEmotionBtn = document.getElementById('prevEmotionBtn');
    const summaryContainer = document.getElementById('summary');

    let matchedEmotions = [];
    let currentEmotionIndex = 0;
    const selections = {
      sensationValues: [],
      emotions: [],
      nuanced: {},
      needs: {}
    };


    function generateSensations() {
      sensationsContainer.innerHTML = '';
      const h2 = document.createElement('h2');
      h2.textContent = "I notice...";
      h2.tabIndex = -1;
      sensationsContainer.appendChild(h2);

      for (part in allSensations){
        const h3 = document.createElement('h3');
        h3.textContent = part.charAt(0).toUpperCase() + part.slice(1);
        sensationsContainer.appendChild(h3);

        Object.keys(allSensations[part]).forEach(sensation => {
          const label = document.createElement('label');
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.value = sensation;
          label.appendChild(input);
          label.appendChild(document.createTextNode(' ' + sensation.replace(/-/g, ' ')));
          sensationsContainer.appendChild(label);
          sensationsContainer.appendChild(document.createElement('br'));
        });

      }
    }

    function buildValueToLabelMap(){
      const map = {};
      document.querySelectorAll('#step1 input[type="checkbox"]').forEach(cb=>{
        map[cb.value] = cb.parentElement.textContent.trim();
      });
      return map;
    }

    step1Btn.addEventListener('click', () => {
      const checked = Array.from(document.querySelectorAll('#step1 input[type="checkbox"]:checked'));

      //array of things like "clenched-jaw"
      selections.sensationValues = checked.map(cb => cb.value);

      //array of same sensations, but without the dash ("clenched jaw")
      selections.emotions = checked.map(cb => cb.parentElement.textContent.trim());

      // need to modify this for new data format
      matchedEmotions = dataset.emotions.filter(emotion =>
        emotion.sensations.some(sensation => selections.sensationValues.includes(sensation))
      );

      step1.classList.add('hidden');

      if (matchedEmotions.length === 0) {
        summaryContainer.classList.remove('hidden');
        summaryContainer.innerHTML = `<h2 id="summaryHeading" tabindex="-1">Summary</h2>
          <p>You did not select any sensations. Refresh the page to start over.</p>`;
        document.getElementById('summaryHeading').focus();
        return;
      }

      step2.classList.remove('hidden');
      currentEmotionIndex = 0;
      renderEmotion();
    });

    function renderEmotion(){
      // need to modify for new data format
      const emotion = matchedEmotions[currentEmotionIndex];

      // ex: {furrowed-brow: "furrowed brow"} not sure why... seems maybe overcomplicated?
      const valueToLabel = buildValueToLabelMap();
      emotionContainer.innerHTML = '';

      const h2 = document.createElement('h2');
      h2.textContent = "I feel...";
      h2.tabIndex = -1;
      emotionContainer.appendChild(h2);

      const h3 = document.createElement('h3');
      //to modify
      h3.textContent = emotion.label;
      emotionContainer.appendChild(h3);

      const live = document.createElement('div');
      live.className = 'sr-only';
      live.setAttribute('aria-live','assertive');
      //to modify
      live.textContent = `Now showing ${emotion.label}`;
      emotionContainer.appendChild(live);

      //why like this??
      const allLabels = emotion.sensations.map(v => valueToLabel[v] || v);
      // const correlatedValues = emotion.sensations.filter(v => selections.sensationValues.includes(v));
      // const correlatedLabels = correlatedValues.map(v => valueToLabel[v] || v);
      const p = document.createElement('p');
      p.textContent = "Often sensed as: " + allLabels.join(', ') +
                      // (correlatedLabels.length ? ". Correlated with your selections: " + correlatedLabels.join(', ') : "");
                      "";
      emotionContainer.appendChild(p);

      //might need to modify with new data format (emotion.key)
      if (!Array.isArray(selections.nuanced[emotion.key])) selections.nuanced[emotion.key] = [];
      if (!Array.isArray(selections.needs[emotion.key])) selections.needs[emotion.key] = [];

      const nuanceLegend = document.createElement('h4');
      nuanceLegend.textContent = "Specifically...";
      emotionContainer.appendChild(nuanceLegend);

      //might need to modify
      emotion.nuanced.forEach(n => {
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.dataset.type = 'nuanced';
        cb.dataset.emotion = emotion.key;
        cb.value = n;
        if (selections.nuanced[emotion.key].includes(n)) cb.checked = true;

        const lbl = document.createElement('label');
        lbl.appendChild(cb);
        lbl.appendChild(document.createTextNode(' ' + n));
        emotionContainer.appendChild(lbl);
        emotionContainer.appendChild(document.createElement('br'));
      });

      //can probably make a function for all these checkboxes instead of doing the same thing 3 times
      const needsLegend = document.createElement('h4');
      needsLegend.textContent = "I need...";
      emotionContainer.appendChild(needsLegend);
      emotion.needs.forEach(n => {
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.dataset.type = 'need';
        cb.dataset.emotion = emotion.key;
        cb.value = n;
        if (selections.needs[emotion.key].includes(n)) cb.checked = true;

        const lbl = document.createElement('label');
        lbl.appendChild(cb);
        lbl.appendChild(document.createTextNode(' ' + n));
        emotionContainer.appendChild(lbl);
        emotionContainer.appendChild(document.createElement('br'));
      });

      nextEmotionBtn.textContent = currentEmotionIndex < matchedEmotions.length - 1 ? 'Next Emotion' : 'See Summary';
      setTimeout(()=> h2.focus(), 0);
    }

    function saveCurrentSelections() {
      const emotion = matchedEmotions[currentEmotionIndex];
      selections.nuanced[emotion.key] = Array.from(document.querySelectorAll(`input[data-type="nuanced"][data-emotion="${emotion.key}"]:checked`)).map(cb=>cb.value);
      selections.needs[emotion.key] = Array.from(document.querySelectorAll(`input[data-type="need"][data-emotion="${emotion.key}"]:checked`)).map(cb=>cb.value);
    }

    nextEmotionBtn.addEventListener('click', () => {
      saveCurrentSelections();
      if (currentEmotionIndex < matchedEmotions.length - 1) {
        currentEmotionIndex++;
        renderEmotion();
      } else {
        step2.classList.add('hidden');
        renderSummary();
      }
    });

    prevEmotionBtn.addEventListener('click', () => {
      saveCurrentSelections();
      if (currentEmotionIndex > 0) {
        currentEmotionIndex--;
        renderEmotion();
      } else {
        step2.classList.add('hidden');
        step1.classList.remove('hidden');
        const firstStep1Input = step1.querySelector('input[type="checkbox"]');
        if (firstStep1Input) setTimeout(()=> firstStep1Input.focus(), 0);
      }
    });

    function renderSummary(){
      saveCurrentSelections(); // save last emotion selections
      summaryContainer.innerHTML = ''; // clear previous

      const heading = document.createElement('h2');
      heading.id = 'summaryHeading';
      heading.tabIndex = -1;
      heading.textContent = 'My current emotions are...';
      summaryContainer.appendChild(heading);

      //everthing below here needs to be reworked
      const pNotice = document.createElement('p');
      pNotice.textContent = `I notice: ${selections.emotions.join(', ') || 'nothing selected'}.`;
      summaryContainer.appendChild(pNotice);

      const selectedNuanced = Object.entries(selections.nuanced).filter(([,arr])=>arr.length).map(([k,arr]) => ({k,arr}));
      const selectedNeeds = Object.entries(selections.needs).filter(([,arr])=>arr.length).map(([k,arr]) => ({k,arr}));

      if (selectedNuanced.length) {
        const ul = document.createElement('ul');
        selectedNuanced.forEach(({k,arr})=>{
          const li = document.createElement('li');
          li.innerHTML = `<strong>${dataset.emotions.find(e=>e.key===k).label}:</strong> ${arr.join(', ')}`;
          ul.appendChild(li);
        });
        summaryContainer.appendChild(document.createElement('h3')).textContent = 'Specifically, by emotion:';
        summaryContainer.appendChild(ul);
      }

      if (selectedNeeds.length) {
        const ul = document.createElement('ul');
        selectedNeeds.forEach(({k,arr})=>{
          const li = document.createElement('li');
          li.innerHTML = `<strong>${dataset.emotions.find(e=>e.key===k).label}:</strong> ${arr.join(', ')}`;
          ul.appendChild(li);
        });
        summaryContainer.appendChild(document.createElement('h3')).textContent = 'Identified needs (by emotion):';
        summaryContainer.appendChild(ul);
      }

      const matchedLabels = matchedEmotions.map(e=>e.label);
      if (matchedLabels.length) {
        const pEmotions = document.createElement('p');
        pEmotions.textContent = `Core emotions suggested by your sensations: ${matchedLabels.join(', ')}.`;
        summaryContainer.appendChild(pEmotions);
      }

      // Add Back button
      const backBtn = document.createElement('button');
      backBtn.type = 'button';
      backBtn.textContent = 'Back';
      backBtn.addEventListener('click', () => {
        summaryContainer.classList.add('hidden');
        step2.classList.remove('hidden');
        renderEmotion();
      });
      summaryContainer.appendChild(backBtn);

      setTimeout(()=> heading.focus(), 0);
      summaryContainer.classList.remove('hidden');
    }

    loadDataset();
  </script>
</body>
</html>
