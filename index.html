<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Emotion Mapper</title>
  <style>
    .hidden { display: none; }
    fieldset { margin-bottom: 1.25rem; }
    h1,h2,h3,h4 { margin: .3rem 0; }
    .summary { border-top: 2px solid #ccc; padding-top: 1rem; margin-top: 1rem; }
    button { margin-top: .5rem; margin-right: .5rem; }
    .sr-only {
      position: absolute;
      left: -9999px;
      width: 1px;
      height: 1px;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <main role="main">
    <h1>Emotion Identification Tool</h1>

    <form id="emotionForm" onsubmit="return false;">
      <!-- Step 1 -->
      <fieldset id="step1">
        <legend>Sensations</legend>
        <div id="sensationsContainer" role="region" area-label="Current sensations"></div>
        <button type="button" id="step1Btn">Next</button>
      </fieldset>

      <!-- Step 2 -->
      <fieldset id="step2" class="hidden" aria-live="polite" aria-atomic="true">
        <legend>Core Emotions</legend>
        <div id="emotionContainer" role="region" aria-label="Current core emotion"></div>
        <button type="button" id="prevEmotionBtn" aria-controls="emotionContainer">Back</button>
        <button type="button" id="nextEmotionBtn" aria-controls="emotionContainer">Next Emotion</button>
      </fieldset>

      <!-- Summary -->
      <div id="summary" class="summary hidden" role="region" aria-label="Summary" aria-live="polite"></div>
    </form>
  </main>

  <script>
    // Data values
    let emotionData = {};
    let partSensations = {};
    let sensationEmotions = {};
    let currentEmotionIndex = 0;
    const selections = {
      sensationValues: [],
      sensationText: [],
      emotions: [],
      nuanced: {},
      needs: {}
    };

    // html elements
    const sensationsContainer = document.getElementById('sensationsContainer');
    const step1 = document.getElementById('step1');
    const step1Btn = document.getElementById('step1Btn');
    const step2 = document.getElementById('step2');
    const emotionContainer = document.getElementById('emotionContainer');
    const nextEmotionBtn = document.getElementById('nextEmotionBtn');
    const prevEmotionBtn = document.getElementById('prevEmotionBtn');
    const summaryContainer = document.getElementById('summary');


    async function loadDataset() {
      const response = await fetch('emotionData.json');
      emotionData = await response.json();

      let sensations, sensation;
      for (const emotion in emotionData){
        sensations = emotionData[emotion].sensations;
        for (const bodyPart in sensations){
          if (partSensations[bodyPart] === undefined) {
            partSensations[bodyPart] = [];
          }
          sensations[bodyPart].forEach(sensation => {
            partSensations[bodyPart].push(sensation);
            sensationEmotions[sensation] = emotion;
          });
        }
        emotionData[emotion].sensations = Object.values(sensations).flat();
      }
      generateSensations();
    }

    function generateSensations() {
      const h2 = document.createElement('h2');
      h2.textContent = "I notice...";
      h2.tabIndex = -1;
      sensationsContainer.appendChild(h2);

      for (part in partSensations){
        const h3 = document.createElement('h3');
        h3.textContent = part.charAt(0).toUpperCase() + part.slice(1);
        sensationsContainer.appendChild(h3);

        partSensations[part].forEach(sensation => {
          const label = document.createElement('label');
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.value = sensation;
          label.appendChild(input);
          label.appendChild(document.createTextNode(' ' + sensation.replace(/-/g, ' ')));
          sensationsContainer.appendChild(label);
          sensationsContainer.appendChild(document.createElement('br'));
        });

      }
    }


    step1Btn.addEventListener('click', () => {
      const checked = Array.from(document.querySelectorAll('#step1 input[type="checkbox"]:checked'));

      //array of things like "clenched-jaw"
      selections.sensationValues = checked.map(cb => cb.value);
      //array of same sensations, but without the dash ("clenched jaw")
      selections.sensationText = new Set(checked.map(cb => cb.parentElement.textContent.trim()));

      let matchedEmotions = new Set(selections.sensationValues.map(sensation => sensationEmotions[sensation]));
      step1.classList.add('hidden');

      if (matchedEmotions.size === 0) {
        summaryContainer.classList.remove('hidden');
        summaryContainer.innerHTML = `<h2 id="summaryHeading" tabindex="-1">Summary</h2>
          <p>You did not select any sensations. Refresh the page to start over.</p>`;
        document.getElementById('summaryHeading').focus();
        return;
      }

      step2.classList.remove('hidden');

      selections.emotions = [...matchedEmotions];
      currentEmotionIndex = 0;
      renderEmotion();
    });

    function renderEmotion(){
      const emotion = selections.emotions[currentEmotionIndex];
      const currentEmotionData = emotionData[emotion];


      const h2 = document.createElement('h2');
      h2.textContent = emotion;
      h2.tabIndex = -1;
      emotionContainer.appendChild(h2);

      const sensedP = document.createElement('p');
      const sensedLabels = [...selections.sensationText].filter(sensation => sensationEmotions[sensation.replace(/\s/g, '-')] === emotion);
      sensedP.textContent = `You noticed ${sensedLabels.join(', ')}.`;
      emotionContainer.appendChild(sensedP);

      const p = document.createElement('p');

      const sensationValuesSet = new Set(selections.sensationValues);
      const excludedLabels = currentEmotionData.sensations.filter(sensation => !sensationValuesSet.has(sensation)).map(sensationValue => sensationValue.replace(/-/g, ' '));

      p.textContent = `Other sensations of ${emotion} can include ${excludedLabels.join(', ')}.`;
      emotionContainer.appendChild(p);

      const h3 = document.createElement('h3');
      h3.textContent = "I feel...";
      emotionContainer.appendChild(h3);

      // What is this for?
      if (!Array.isArray(selections.nuanced[emotion])) selections.nuanced[emotion] = [];
      if (!Array.isArray(selections.needs[emotion])) selections.needs[emotion] = [];

      currentEmotionData.nuancedEmotions.forEach(n => {
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.dataset.type = 'nuanced';
        cb.dataset.emotion = emotion;
        cb.value = n;
        if (selections.nuanced[emotion].includes(n)) cb.checked = true;

        const lbl = document.createElement('label');
        lbl.appendChild(cb);
        lbl.appendChild(document.createTextNode(' ' + n));
        emotionContainer.appendChild(lbl);
        emotionContainer.appendChild(document.createElement('br'));
      });

      //can probably make a function for all these checkboxes instead of doing the same thing 3 times
      const needsLegend = document.createElement('h3');
      needsLegend.textContent = "I need " + currentEmotionData.coreNeed + ":";
      emotionContainer.appendChild(needsLegend);
      currentEmotionData.nuancedNeeds.forEach(n => {
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.dataset.type = 'need';
        cb.dataset.emotion = emotion;
        cb.value = n;
        if (selections.needs[emotion].includes(n)) cb.checked = true;

        const lbl = document.createElement('label');
        lbl.appendChild(cb);
        lbl.appendChild(document.createTextNode(' ' + n));
        emotionContainer.appendChild(lbl);
        emotionContainer.appendChild(document.createElement('br'));
      });

            //This might not be necessary
      const live = document.createElement('div');
      live.className = 'sr-only';
      live.setAttribute('aria-live','assertive');
      //to modify
      live.textContent = `Now showing ${emotion}`;
      emotionContainer.appendChild(live);

      nextEmotionBtn.textContent = currentEmotionIndex < selections.emotions.length - 1 ? 'Next Emotion' : 'See Summary';
      setTimeout(()=> h2.focus(), 0);
    }

    function saveCurrentSelections() {
      const emotion = selections.emotions[currentEmotionIndex];
      selections.nuanced[emotion] = Array.from(document.querySelectorAll(`input[data-type="nuanced"][data-emotion="${emotion}"]:checked`)).map(cb=>cb.value);
      selections.needs[emotion] = Array.from(document.querySelectorAll(`input[data-type="need"][data-emotion="${emotion}"]:checked`)).map(cb=>cb.value);
    }

    nextEmotionBtn.addEventListener('click', () => {
      saveCurrentSelections();
      if (currentEmotionIndex < selections.emotions.length - 1) {
        currentEmotionIndex++;
        renderEmotion();
      } else {
        step2.classList.add('hidden');
        renderSummary();
      }
    });

    prevEmotionBtn.addEventListener('click', () => {
      saveCurrentSelections();
      if (currentEmotionIndex > 0) {
        currentEmotionIndex--;
        renderEmotion();
      } else {
        step2.classList.add('hidden');
        step1.classList.remove('hidden');
        const firstStep1Input = step1.querySelector('input[type="checkbox"]');
        if (firstStep1Input) setTimeout(()=> firstStep1Input.focus(), 0);
      }
    });

    function renderSummary(){

      // NEXT: rearrange this so that "Overall" is the same styling as "Core Emotion" on previous page (and is a form)
      // Underneath, summarized version of each core emotion that parallels the previous page
      // as each thing tried is checked off, add checklist underneath of just tried, and give a rating of how helpful each was
      saveCurrentSelections(); // save last emotion selections
      summaryContainer.innerHTML = ''; // clear previous

      const heading = document.createElement('h2');
      heading.id = 'summaryHeading';
      heading.tabIndex = -1;
      heading.textContent = "Overall";
      summaryContainer.appendChild(heading);

      const selectedNuanced = new Map(Object.entries(selections.nuanced));

      const needsArr = Object.entries(selections.needs);
      let numNeeds = needsArr.reduce ((sum, [emotion, needArr]) => {
        return sum + needArr.length;
      },0);
      const selectedNeeds = new Map(needsArr);

      if (selectedNuanced.size) {
        const ul = document.createElement('ul');
        selectedNuanced.forEach((feelings, emotion)=>{
          const li = document.createElement('li');
          li.innerHTML = `<strong>${emotion}</strong> - ${feelings.join(', ')}`;
          ul.appendChild(li);
        });
        summaryContainer.appendChild(document.createElement('h3')).textContent =  `I notice ${[...selections.sensationText].join(', ') || 'nothing selected'}.`;

        summaryContainer.appendChild(ul);
      }

      summaryContainer.appendChild(
         document.createElement('h3')
      ).textContent = (numNeeds > 0) ? 'I need (select the ones you try)' : `No needs selected.`;
      if (numNeeds > 0) {
        // const ul = document.createElement('ul');
        selectedNeeds.forEach(needs => {
          needs.forEach(need => {
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.dataset.type = 'tried';
            // cb.dataset.emotion = emotion;
            cb.value = need;

            const lbl = document.createElement('label');
            lbl.appendChild(cb);
            lbl.appendChild(document.createTextNode(' ' + need));
            summaryContainer.appendChild(lbl);
            summaryContainer.appendChild(document.createElement('br'));

          });
        });

      }

      // Add Back button
      const backBtn = document.createElement('button');
      backBtn.type = 'button';
      backBtn.textContent = 'Back';
      backBtn.addEventListener('click', () => {
        summaryContainer.classList.add('hidden');
        step2.classList.remove('hidden');
        renderEmotion();
      });
      summaryContainer.appendChild(backBtn);

      setTimeout(()=> heading.focus(), 0);
      summaryContainer.classList.remove('hidden');
    }

    loadDataset();
  </script>
</body>
</html>
