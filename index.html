<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Emotion Mapper</title>
  <style>
    .hidden { display: none; }
    fieldset { margin-bottom: 1.25rem; }
    h1,h2,h3,h4 { margin: .3rem 0; }
    .summary { border-top: 2px solid #ccc; padding-top: 1rem; margin-top: 1rem; }
    button { margin-top: .5rem; margin-right: .5rem; }
    .sr-only {
      position: absolute;
      left: -9999px;
      width: 1px;
      height: 1px;
      overflow: hidden;
    }
    .checkbox-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 0rem 1rem;
    }
    .checkbox-group label {
      display: flex;
      align-items: center;
    }
    .checkbox-group input[type="checkbox"] {
      margin-right: 0.5rem; /* Adjust spacing as needed */
    }
    .horizontal-line {
      border-top: 1px solid black; /* Creates a 1px solid black line at the top */
      margin: 10px 0; /* Adds some space above and below the line */
    }
  </style>
</head>
<body>
  <main role="main">
    <h1>Emotion Identification Tool</h1>

    <form id="emotionForm" onsubmit="return false;">
      <!-- Step 1 -->
      <fieldset id="step1">
        <legend>Sensations</legend>
        <button type="button" id="skipSensationsBtn">Skip and explore all emotions</button>
        <div id="sensationsContainer" role="region" area-label="Current sensations"></div>
        <button type="button" id="step1Btn">Next</button>
      </fieldset>

      <!-- Step 2 -->
      <fieldset id="step2" class="hidden" aria-live="polite" aria-atomic="true">
        <legend>Core Emotion</legend>
        <div id="emotionContainer" role="region" aria-label="Current core emotion"></div>
        <button type="button" id="prevEmotionBtn" aria-controls="emotionContainer">Back</button>
        <button type="button" id="nextEmotionBtn" aria-controls="emotionContainer">Next Emotion</button>
      </fieldset>

      <!-- Step 3 -->
      <fieldset id="step3" class="hidden" aria-live="polite">
        <legend>Summary</legend>
        <div id="summaryContainer" role="region" aria-label="Summary"></div>
        <button type="button" id="step3BackBtn" aria-controls="summaryContainer">Back</button>
        <button id="copyBtn">Copy Summary</button>
      </fieldset>
    </form>
  </main>

  <script>
    let emotionData = {};
    let partSensations = {};
    let sensationEmotions = {};
    let currentEmotionIndex = 0;
    const selections = {
      sensations: [],
      emotions: [],
      nuanced: {},
      needs: {}
    };
    /* IDEAS FROM NICK
      - Make text in selected items change-- stray clicks might not obvious to someone with low vision
      - Button to copy summary page?
      - Input to enter text for "something else"?
    */
    const step1 = document.getElementById('step1');
    const sensationsContainer = document.getElementById('sensationsContainer');
    const skipSensationsBtn = document.getElementById('skipSensationsBtn');
    const step1Btn = document.getElementById('step1Btn');

    const step2 = document.getElementById('step2');
    const emotionContainer = document.getElementById('emotionContainer');
    const nextEmotionBtn = document.getElementById('nextEmotionBtn');
    const prevEmotionBtn = document.getElementById('prevEmotionBtn');

    const step3 = document.getElementById('step3');
    const summaryContainer = document.getElementById('summaryContainer');
    const step3BackBtn = document.getElementById('step3BackBtn');
    const copySummaryBtn = document.getElementById('copyBtn');


    async function loadDataset() {
      const response = await fetch('emotionData.json');
      emotionData = await response.json();

      let sensations, sensation;
      for (const emotion in emotionData){
        sensations = emotionData[emotion].sensations;
        for (const bodyPart in sensations){
          if (partSensations[bodyPart] === undefined) {
            partSensations[bodyPart] = [];
          }
          sensations[bodyPart].forEach(sensation => {
            partSensations[bodyPart].push(sensation);
            sensationEmotions[sensation] = emotion;
          });
        }
        emotionData[emotion].sensations = Object.values(sensations).flat();
      }
      generateSensations();
    }

    function createTextElement(type, content, srFocus){
      const header = document.createElement(type);
      header.textContent = content;
      if (srFocus) header.tabIndex = -1;
      return header;
    }

    function createCheckbox(value, container, addBreak){
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.value = value;

      const label = document.createElement('label');
      label.appendChild(input);
      label.appendChild(document.createTextNode(' ' + value));

      container.appendChild(label);
      if (addBreak) container.appendChild(document.createElement('br'));

      return input;
    }

    function generateSensations() {
      sensationsContainer.appendChild(createTextElement("h2", "I notice...", true));

      for (part in partSensations){
        sensationsContainer.appendChild(
          createTextElement("h3", part.charAt(0).toUpperCase() + part.slice(1), false));
        const groupDiv = document.createElement('div');
        groupDiv.className = 'checkbox-group';
        sensationsContainer.appendChild(groupDiv);

        partSensations[part].forEach(sensation => {
          createCheckbox(sensation, groupDiv);
        });
      }
    }

    skipSensationsBtn.addEventListener('click', () => {
      selections.emotions = Object.keys(emotionData);
      currentEmotionIndex = 0;
      step1.classList.add('hidden');
      step2.classList.remove('hidden');
      nextEmotionBtn.classList.remove('hidden');
      renderEmotion();
    });

    step1Btn.addEventListener('click', () => {
      const checked = Array.from(document.querySelectorAll('#step1 input[type="checkbox"]:checked'));

      //array of things like "clenched-jaw"
      selections.sensations = checked.map(cb => cb.value);

      let matchedEmotions = new Set(selections.sensations.map(sensation => sensationEmotions[sensation]));
      step1.classList.add('hidden');
      step2.classList.remove('hidden');
      if (matchedEmotions.size === 0) {
        nextEmotionBtn.classList.add('hidden');
        emotionContainer.innerHTML = `<h2 id="error">You did not select any sensations.</h2>`;
        document.getElementById('error').focus();
        return;
      }
      nextEmotionBtn.classList.remove('hidden');
      selections.emotions = [...matchedEmotions];
      currentEmotionIndex = 0;
      renderEmotion();
    });

    function renderEmotion(){
      emotionContainer.innerHTML = '';

      const emotion = selections.emotions[currentEmotionIndex];
      const currentEmotionData = emotionData[emotion];

      const h2 = emotionContainer.appendChild(createTextElement("h2",emotion,true));

      if (selections.sensations.length > 0){
        const sensedLabels = [...selections.sensations].filter(sensation => sensationEmotions[sensation] === emotion);
        emotionContainer.appendChild(createTextElement("p",`You noticed ${sensedLabels.join(', ')}.`));

        const sensationValuesSet = new Set(selections.sensations);
        const excludedLabels = currentEmotionData.sensations.filter(sensation => !sensationValuesSet.has(sensation));
        emotionContainer.appendChild(createTextElement("p",`Other sensations of ${emotion} can include ${excludedLabels.join(', ')}.`));
      } else {
         emotionContainer.appendChild(createTextElement("p",`Sensations of ${emotion} can include ${currentEmotionData.sensations.join(', ')}.`));
      }

      emotionContainer.appendChild(createTextElement('h3', 'I feel...'));
      if (!Array.isArray(selections.nuanced[emotion])) selections.nuanced[emotion] = [];

      const nuancedGroupDiv = document.createElement('div');
      nuancedGroupDiv.className = 'checkbox-group';
      emotionContainer.appendChild(nuancedGroupDiv);

      currentEmotionData.nuancedEmotions.forEach(nuEmotion => {
        const cb = createCheckbox(nuEmotion, nuancedGroupDiv);
        cb.dataset.type = 'nuanced';
        cb.dataset.emotion = emotion;
        if (selections.nuanced[emotion].includes(nuEmotion)) cb.checked = true;
      });

      emotionContainer.appendChild(document.createElement('br'));

      emotionContainer.appendChild(createTextElement('h3', `I need ${currentEmotionData.coreNeed} and will try...`));
      if (!Array.isArray(selections.needs[emotion])) selections.needs[emotion] = [];

      currentEmotionData.nuancedNeeds.forEach(nuNeed => {
        const cb = createCheckbox(nuNeed, emotionContainer, true);
        cb.dataset.type = 'need';
        cb.dataset.emotion = emotion;
        if (selections.needs[emotion].includes(nuNeed)) cb.checked = true;
      });

      nextEmotionBtn.textContent = currentEmotionIndex < selections.emotions.length - 1 ? 'Next Emotion' : 'See Summary';
      setTimeout(()=> h2.focus(), 0);
    }

    function saveCurrentSelections() {
      const emotion = selections.emotions[currentEmotionIndex];
      selections.nuanced[emotion] = Array.from(document.querySelectorAll(`input[data-type="nuanced"][data-emotion="${emotion}"]:checked`)).map(cb=>cb.value);
      selections.needs[emotion] = Array.from(document.querySelectorAll(`input[data-type="need"][data-emotion="${emotion}"]:checked`)).map(cb=>cb.value);
    }

    nextEmotionBtn.addEventListener('click', () => {
      saveCurrentSelections();
      if (currentEmotionIndex < selections.emotions.length - 1) {
        currentEmotionIndex++;
        renderEmotion();
      } else {
        step2.classList.add('hidden');
        step3.classList.remove('hidden');
        renderSummary();
      }
    });

    prevEmotionBtn.addEventListener('click', () => {
      saveCurrentSelections();
      if (currentEmotionIndex > 0) {
        currentEmotionIndex--;
        renderEmotion();
      } else {
        step2.classList.add('hidden');
        step1.classList.remove('hidden');
      }
    });

    function renderSummary(){
      saveCurrentSelections(); // save last emotion selections
      summaryContainer.innerHTML = ''; // clear previous

      const selectedSensations = selections.sensations;
      const selectedNuanced = selections.nuanced;
      const selectedNeeds = selections.needs;

      if (!(selectedSensations.length || Object.values(selectedNuanced).flat().length || Object.values(selectedNeeds).flat().length)){
        summaryContainer.innerHTML = `<h2 id="error">You did not select anything. Go back to previous emotion/s or refresh page to start over.</h2>`;
      }

      selections.emotions.forEach(emotion => {
        const emotionSensations = [...selectedSensations].filter(sensation => sensationEmotions[sensation] === emotion);
        const nuancedEmotions = selectedNuanced[emotion];
        const emotionNeeds = selectedNeeds[emotion];

        if (!(emotionNeeds.length || nuancedEmotions.length)) {
          return;
        }

        summaryContainer.appendChild(createTextElement('h3',`Core Emotion: ${emotion}`,true));

        let sensationText;
        if (emotionSensations.length > 0){
          sensationText = createTextElement('h4',`I notice ${emotionSensations.join(', ')}`);
        } else {
          sensationText = createTextElement('p',`Sensations of ${emotion} can include ${emotionData[emotion].sensations.join(', ')}.`);
        }
        summaryContainer.appendChild(sensationText);

        let nuacedText;
        if (nuancedEmotions.length > 0){
          nuacedText = `Specifically, I feel ${nuancedEmotions.join(', ')}`;
        } else {
          nuacedText = 'No specific feelings selected';
        }
        summaryContainer.appendChild(createTextElement('h4',nuacedText));

        summaryContainer.appendChild(createTextElement('h4',`I need ${emotionData[emotion].coreNeed}`));

        if (emotionNeeds.length > 0) {
          emotionNeeds.forEach(need => {
            createCheckbox(need, summaryContainer, true)
          });
        } else {
          createCheckbox('No specific needs selected.',summaryContainer);
          summaryContainer.appendChild(document.createElement('br'));
        }
        summaryContainer.appendChild(document.createElement('br'));
        const line = summaryContainer.appendChild(document.createElement('div'));
        line.classList.add('horizontal-line');
      });
    }

    step3BackBtn.addEventListener('click', () => {
        step3.classList.add('hidden');
        if (selections.emotions.length === 0) {
          step1.classList.remove('hidden');
        } else {
          step2.classList.remove('hidden');
        }
    });

    copySummaryBtn.addEventListener("click", () => {
      const summaryText = document.getElementById("summaryContainer").innerText;
      navigator.clipboard.writeText(summaryText).then(() => {
        console.log("Summary copied to clipboard!");
      }).catch(err => {
        console.error("Failed to copy text: ", err);
      });
});

    loadDataset();
  </script>
</body>
</html>
