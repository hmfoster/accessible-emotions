<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Emotion Mapper</title>
  <style>
    .hidden { display: none; }
    fieldset { margin-bottom: 1.25rem; }
    h1,h2,h3,h4 { margin: .3rem 0; }
    .summary { border-top: 2px solid #ccc; padding-top: 1rem; margin-top: 1rem; }
    button { margin-top: .5rem; margin-right: .5rem; }
    .sr-only {
      position: absolute;
      left: -9999px;
      width: 1px;
      height: 1px;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <main role="main">
    <h1>Emotion Identification Tool</h1>

    <form id="emotionForm" onsubmit="return false;">
      <!-- Step 1 -->
      <fieldset id="step1">
        <legend>Sensations</legend>
        <div id="sensationsContainer" role="region" area-label="Current sensations"></div>
        <button type="button" id="step1Btn">Next</button>
      </fieldset>

      <!-- Step 2 -->
      <fieldset id="step2" class="hidden" aria-live="polite" aria-atomic="true">
        <legend>Core Emotions</legend>
        <div id="emotionContainer" role="region" aria-label="Current core emotion"></div>
        <button type="button" id="prevEmotionBtn" aria-controls="emotionContainer">Back</button>
        <button type="button" id="nextEmotionBtn" aria-controls="emotionContainer">Next Emotion</button>
      </fieldset>

      <!-- Summary -->
      <div id="summary" class="summary hidden" role="region" aria-label="Summary" aria-live="polite"></div>
    </form>
  </main>

  <script>
    // Data values
    let emotionData = {};
    let partSensations = {};
    let sensationEmotions = {};
    let currentEmotionIndex = 0;
    const selections = {
      sensationValues: [],
      sensationText: [],
      emotions: [],
      nuanced: {},
      needs: {}
    };

    // html elements
    const sensationsContainer = document.getElementById('sensationsContainer');
    const step1 = document.getElementById('step1');
    const step1Btn = document.getElementById('step1Btn');
    const step2 = document.getElementById('step2');
    const emotionContainer = document.getElementById('emotionContainer');
    const nextEmotionBtn = document.getElementById('nextEmotionBtn');
    const prevEmotionBtn = document.getElementById('prevEmotionBtn');
    const summaryContainer = document.getElementById('summary');


    async function loadDataset() {
      const response = await fetch('emotionData.json');
      emotionData = await response.json();

      let sensations, sensation;
      for (const emotion in emotionData){
        sensations = emotionData[emotion].sensations;
        for (const bodyPart in sensations){
          if (partSensations[bodyPart] === undefined) {
            partSensations[bodyPart] = [];
          }
          sensations[bodyPart].forEach(sensation => {
            partSensations[bodyPart].push(sensation);
            sensationEmotions[sensation] = emotion;
          });
        }
        emotionData[emotion].sensations = Object.values(sensations).flat();
      }
      generateSensations();
    }

    function createTextElement(type, content, srFocus){
      const header = document.createElement(type);
      header.textContent = content;
      if (srFocus) header.tabIndex = -1;
      return header;
    }

    function createCheckbox(inputVal, text, container){
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.value = inputVal;

      const label = document.createElement('label');
      label.appendChild(input);
      label.appendChild(document.createTextNode(' ' + text));

      container.appendChild(label);
      container.appendChild(document.createElement('br'));

      return input;
    }

    function generateSensations() {
      sensationsContainer.appendChild(createTextElement("h2", "I notice...", true));

      for (part in partSensations){
        sensationsContainer.appendChild(
          createTextElement("h3",
            part.charAt(0).toUpperCase() + part.slice(1),
            false)
          );

        partSensations[part].forEach(sensation => {
          createCheckbox(sensation, sensation.replace(/-/g, ' '), sensationsContainer);
        });
      }
    }

    step1Btn.addEventListener('click', () => {
      const checked = Array.from(document.querySelectorAll('#step1 input[type="checkbox"]:checked'));

      //array of things like "clenched-jaw"
      selections.sensationValues = checked.map(cb => cb.value);
      //array of same sensations, but without the dash ("clenched jaw")
      selections.sensationText = new Set(checked.map(cb => cb.parentElement.textContent.trim()));

      let matchedEmotions = new Set(selections.sensationValues.map(sensation => sensationEmotions[sensation]));
      step1.classList.add('hidden');

      if (matchedEmotions.size === 0) {
        summaryContainer.classList.remove('hidden');
        summaryContainer.innerHTML = `<h2 id="summaryHeading" tabindex="-1">Summary</h2>
          <p>You did not select any sensations. Refresh the page to start over.</p>`;
        document.getElementById('summaryHeading').focus();
        return;
      }

      step2.classList.remove('hidden');

      selections.emotions = [...matchedEmotions];
      currentEmotionIndex = 0;
      renderEmotion();
    });

    function renderEmotion(){
      emotionContainer.innerHTML = '';

      const emotion = selections.emotions[currentEmotionIndex];
      const currentEmotionData = emotionData[emotion];

      const h2 = emotionContainer.appendChild(createTextElement("h2",emotion,true));

      const sensedLabels = [...selections.sensationText].filter(sensation => sensationEmotions[sensation.replace(/\s/g, '-')] === emotion);
      emotionContainer.appendChild(createTextElement("p",`You noticed ${sensedLabels.join(', ')}.`));

      const sensationValuesSet = new Set(selections.sensationValues);
      const excludedLabels = currentEmotionData.sensations.filter(sensation => !sensationValuesSet.has(sensation)).map(sensationValue => sensationValue.replace(/-/g, ' '));
      emotionContainer.appendChild(createTextElement("p",`Other sensations of ${emotion} can include ${excludedLabels.join(', ')}.`));

      emotionContainer.appendChild(createTextElement('h3', 'I feel...'));
      if (!Array.isArray(selections.nuanced[emotion])) selections.nuanced[emotion] = [];
      currentEmotionData.nuancedEmotions.forEach(nuEmotion => {
        const cb = createCheckbox(nuEmotion, nuEmotion, emotionContainer);
        cb.dataset.type = 'nuanced';
        cb.dataset.emotion = emotion;
        if (selections.nuanced[emotion].includes(nuEmotion)) cb.checked = true;
      });

      emotionContainer.appendChild(document.createElement('br'));

      emotionContainer.appendChild(createTextElement('h3', `I need ${currentEmotionData.coreNeed}...`));
      if (!Array.isArray(selections.needs[emotion])) selections.needs[emotion] = [];
      currentEmotionData.nuancedNeeds.forEach(nuNeed => {
        const cb = createCheckbox(nuNeed, nuNeed, emotionContainer);
        cb.dataset.type = 'need';
        cb.dataset.emotion = emotion;
        if (selections.needs[emotion].includes(nuNeed)) cb.checked = true;
      });

      nextEmotionBtn.textContent = currentEmotionIndex < selections.emotions.length - 1 ? 'Next Emotion' : 'See Summary';
      setTimeout(()=> h2.focus(), 0);
    }

    function saveCurrentSelections() {
      const emotion = selections.emotions[currentEmotionIndex];
      selections.nuanced[emotion] = Array.from(document.querySelectorAll(`input[data-type="nuanced"][data-emotion="${emotion}"]:checked`)).map(cb=>cb.value);
      selections.needs[emotion] = Array.from(document.querySelectorAll(`input[data-type="need"][data-emotion="${emotion}"]:checked`)).map(cb=>cb.value);
    }

    nextEmotionBtn.addEventListener('click', () => {
      saveCurrentSelections();
      if (currentEmotionIndex < selections.emotions.length - 1) {
        currentEmotionIndex++;
        renderEmotion();
      } else {
        step2.classList.add('hidden');
        renderSummary();
      }
    });

    prevEmotionBtn.addEventListener('click', () => {
      saveCurrentSelections();
      if (currentEmotionIndex > 0) {
        currentEmotionIndex--;
        renderEmotion();
      } else {
        step2.classList.add('hidden');
        step1.classList.remove('hidden');
        const firstStep1Input = step1.querySelector('input[type="checkbox"]');
        if (firstStep1Input) setTimeout(()=> firstStep1Input.focus(), 0);
      }
    });

    function renderSummary(){

      // NEXT: rearrange this so that "Overall" is the same styling as "Core Emotion" on previous page (and is a form)
      // Underneath, summarized version of each core emotion that parallels the previous page
      // as each thing tried is checked off, add checklist underneath of just tried, and give a rating of how helpful each was

      saveCurrentSelections(); // save last emotion selections
      summaryContainer.innerHTML = ''; // clear previous

      const h2 = summaryContainer.appendChild(createTextElement('h2','Overall',true));

      const selectedNuanced = new Map(Object.entries(selections.nuanced));
      if (selectedNuanced.size) {
        const ul = document.createElement('ul');
        selectedNuanced.forEach((feelings, emotion)=>{
          const li = document.createElement('li');
          li.innerHTML = `<strong>${emotion}</strong> - ${feelings.join(', ')}`;
          ul.appendChild(li);
        });
        summaryContainer.appendChild(createTextElement('h3', `I notice ${[...selections.sensationText].join(', ')}`));
        summaryContainer.appendChild(ul);
      }

      const needsArr = Object.entries(selections.needs);
      let numNeeds = needsArr.reduce ((sum, [emotion, needArr]) => {
        return sum + needArr.length;
      },0);
      summaryContainer.appendChild(createTextElement('h3', (numNeeds > 0) ? 'I need (select the ones you try)' : `No needs selected.`))

      const selectedNeeds = new Map(needsArr);
      if (numNeeds > 0) {
        // const ul = document.createElement('ul');
        selectedNeeds.forEach(needs => {
          needs.forEach(need => {
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.dataset.type = 'tried';
            // cb.dataset.emotion = emotion;
            cb.value = need;

            const lbl = document.createElement('label');
            lbl.appendChild(cb);
            lbl.appendChild(document.createTextNode(' ' + need));
            summaryContainer.appendChild(lbl);
            summaryContainer.appendChild(document.createElement('br'));
          });
        });
      }

      const backBtn = createTextElement('button','Back')
      backBtn.addEventListener('click', () => {
        summaryContainer.classList.add('hidden');
        step2.classList.remove('hidden');
        renderEmotion();
      });
      summaryContainer.appendChild(backBtn);

      setTimeout(()=> h2.focus(), 0);
      summaryContainer.classList.remove('hidden');
    }

    loadDataset();
  </script>
</body>
</html>
